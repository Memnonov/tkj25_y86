# Calling Conventions

# Arguments:
#     multiply(a, b)                   : %rsi = a, %rdi = b
#     halve(dividend)                  : %rbx = dividend
#     fast_modulo(dividend, modulo)    : %rsi = dividend, %rdi =  modulo
#     modpow(base, exponent, modulo)   : %rsi = base, %rbx = exponent, %rdi = modulo
#     miller_rabin(candidate, witness) : %rsi = candidate, %rdi = witness

# Return values: %rax

# %rsi and %rdi are used as arguments for subroutine call and
# are callee-saved during them. Otherwise safety while calls 
# is enforced by tha caller.

# %rbx holds p while doing miller_rabin_rounds.



#.pos 0
    irmovq    stack, %rbp
    irmovq    stack, %rsp
#    irmovq    $0x1800, %r8            # array start at %r8

testing:
    #irmovq    $666, %rsi
    #irmovq    $2, %rdi
    #call      multiply
    #rrmovq    %rax, %rsi
    #call      halve
    #rrmovq    %rax, %rsi
    #irmovq    $77, %rdi
    #call      fast_modulo
    #irmovq     $22, %rsi          # BASE
    #irmovq     $666, %rbx         # EXPONENT
    #irmovq     $15, %rdi          # MODULO
    #call       modpow

# Main program using:
#    %rcx    :    pointer to input array
#    %rdx    :    pointer to witness array
#    %rsi    :    witness
#    %rdi    :    candidate
#
# Complexity:
# Most of the main program is pretty negligible compared to the modpow calls
# made in miller_rabin_round. It is is nested loop, but the input and witness
# arrays are very small. The heaviest work is done when finding a large
# enough prime, which means having to iterate through all the witnesses while
# making expensive calls to miller_rabin_round. If we assume miller_rabin_round
# to make around 2 calls to modpow, we could expect 22,4k operations times the
# 13 witness numbers which comes to a total of ~290k operations. It seems
# that in reality many compounds and primes are found more easily based on 
# the slowest runs in Lovelace being around 240k. This could mean some ~20
# calls to modpow. Taking early exits, like culling even numbers, is
# important here.
main:
    rrmovq    %r8, %rcx                  # move input array pointer to %rxc
    irmovq    $0x1000, %rdx              # witness array pointer to %rdx

# Outer loop iterates through the input array and validates the values
input_loop:
    xorq      %rax, %rax                 # init return value as 0
    mrmovq    0(%rcx), %rdi              # fetch current prime candidate to %rdi
    andq      %rdi, %rdi                 # check for terminating zero
    je        done                       # zero, no PRIMES in input array
    
    # Update pointers
    irmovq    $8, %rax                   # array offset 8 to %rax
    addq      %rax, %rcx                 # increment input pointer
    irmovq    witnesses, %rdx            # reset witness array pointer

    # Check if the candidate is 2
    irmovq    $1, %r9                  # const 1 to %r9
    rrmovq    %rdi, %r8                # move temp candidate to %r8
    subq      %r9, %r8                 # subtract 1
    subq      %r9, %r8                 # subtract 1 again, goes to 0 if 2
    je        prime_found              # found PRIME 2
    
    # Check if even or 1
    rrmovq    %rdi, %r8                # move temp candidate to %r8
    andq      %r9, %r8                 # check first bit with AND 1
    je        input_loop               # Even -> COMPOUND
    rrmovq    %rdi, %r8                # move temp candidate to %r8
    subq      %r9, %r8                 # compare to 1
    je        input_loop               # candidate was 1, not a PRIME
   


# Inner loop tests a possible prime against witnesses
witness_loop:
    mrmovq    0(%rdx), %rsi            # fetch current witness to %rsi
    andq      %rsi, %rsi               # at the end of witness array
    je        prime_found              # all tests passed -> PRIME found
    
    # Advance witness array pointer
    irmovq    $8, %rax                 # array offset 8 to %rax
    addq      %rax, %rdx               # increment witness pointer by 8
    
    # Check if number >= witness
    rrmovq    %rdi, %r8                # candidate temp to %r8
    subq      %rsi, %r8                # compare with witness
    cmovle    %rdi, %rax               # passed all tests with valid witnesses -> PRIME
    jle       witness_loop             # no more valid witnesses -> PRIME
    
    # Save main loop state
    pushq     %rcx                     # input pointer to stack
    pushq     %rdx                     # witness pointer to stack
    
    call      miller_rabin_round       # miller_rabin_round(candidate, witness)

    popq      %rdx                     # pop witness pointer from stack
    popq      %rcx                     # pop input pointer from stack
    
    andq      %rax, %rax               # check round result
    je        input_loop               # COMPOUND if zero -> next candidate
    
    jmp       witness_loop             # iterate with next witness

prime_found:
    rrmovq    %rdi, %rax               # move PRIME to %rax for return

done:
    halt

# Subroutine miller_rabin_round(long candidate, long witness)
# witness in %rsi
# candidate in % rdi
# Using:
#    %rsi = witness
#    %rdi = candidate
#    %rbx = p
#    %rdx = candidate - 1
#    %rcx = const 1
#    The ordering makes calling modpow easy since the witness
#    and candidate will stay nicely in the right registers and 
#    only p is modified while iterating!
# clobbers: %rax, %rbx, %rcx, %rdx, %rbx, %r8 - 14

# Performance:
# The performance is dominated by the calls to modpow while looping.
# Assuming the costs assumed in other subroutines just having to call
# modpow twice could mean 22,4k operations. This is expensive but also 
# very swingy based on how early the compound numbers are caught.
miller_rabin_round:
    irmovq    $1, %rcx          # init const 1 to %rcx
    rrmovq    %rdi, %rdx        # init candidate - 1 to %rdx
    subq      %rcx, %rdx        # subtract to get candidate - 1
    rrmovq    %rdx, %rbx        # init p = candidate - 1 to %rbx

    # check if modpow(witness, p, number) != 1
    call      modpow            # modpow(witness, p, candidate)
    subq      %rcx, %rax        # compare result with 1
    jne       compound          # found COMPOUND
    
p_halving_loop:
    # Check if (p AND 1)
    rrmovq    %rbx, %r8         # temp of p to %r8
    andq      %rcx, %r8         # p AND 1
    jne       prime             # p was odd -> PRIME
    
    # Halve p and recheck
    call      halve             # halves the p in %rbx
    call      modpow            # modpow with the halved p
   
    # Check if (result == 1)
    rrmovq    %rax, %r8         # result temp to %r8
    subq      %rcx, %r8         # compare with  1
    je        p_halving_loop    # continue
    
    # Check if (result == number - 1)
    rrmovq    %rax, %r8         # result temp to %r8
    subq      %rdx, %r8         # compare with candidate - 1
    je        prime             # found PRIME
   
    # Else
    jmp       compound          # found COMPOUND


compound:
    irmovq    $0, %rax          # COMPOUND -> return 0
    jmp       miller_rabin_done

prime:
    rrmovq    %rcx, %rax        # PRIME -> return const 1

miller_rabin_done:
    ret

# Subroutine multiply(long a, long b)
# a in %rsi
# b in %rdi
# return value in %rax
# clobbers: %rax, %r8, %r9, %r10
# 
# Complexity:
# Multiply iterates through all the bits of input a meaning 
# a worst case of approximately 16 operations per set bit.
# O(n) scaling where n is the number of bits.
# A sixteen bit integer like 0bFFFF would take ~10 operations
# an iteration meaning ~160 operations in total.
multiply:
    irmovq     $0x1, %r8            # init bit mask in %rbx
    rrmovq     %rdi, %r10           # init mutable temp of the second operand
    xorq       %rax, %rax           # init accumulator %rax = 0

multiply_loop:
    rrmovq    %rsi, %r9             # temp of operand
    subq      %r8, %r9              # check for relevant bits left
    jl        multiply_done         # no more terms
    rrmovq    %rsi, %r9             # temp of operand
    andq      %r8, %r9              # use mask to check current term
    je        do_them_shifts        # term was 0 -> iterate
    addq      %r10, %rax            # result += shift of the operand
    
do_them_shifts:
    addq      %r8, %r8              # left shift mask  
    addq      %r10, %r10            # left shift operand
    jmp       multiply_loop
    
multiply_done:
    ret                             # return result in %rax

# Subroutine halve(long dividend)
# dividend in %rbx (%rbx holds p during the miller_rabin_round!)
# return value in %rax
# clobbers: %rax, %rbx %r8, %r9, %r10 (side effects in %rbx!)
#
# Complexity: 
# Like with multiply, halves operation cost is mainly determined
# by the amount of bits we have to iterate through in the dividend.
# Therefore, O(n) where n is the amount of bits.
# With ~10 operations per loop, something like 0xFFFF would take ~160 operations.
halve:
    irmovq    $0x2, %r8                  # init single bit mask in at 0b10
    irmovq    $1, %r9                    # init cursor in %r9 at 0b01
    xorq      %rax, %rax                 # init accumulator = 0 in %rax
    
halve_loop:
    rrmovq    %rbx, %r10                 # tmp of the dividend
    subq      %r8, %r10                  # check for bits to process
    jl        halve_done                 # no more bits
    rrmovq    %rbx, %r10                 # tmp of the dividend
    andq      %r8, %r10                  # check current bit
    je        update_halve_parameters    # current term = 0 -> iterate
    addq      %r9, %rax                  # add cursor to accumulator
    
update_halve_parameters:
   rrmovq     %r8, %r9                   # make old mask the new cursor
   addq       %r8, %r8                   # shift the mask
   jmp        halve_loop                 # loopidy loop
    
halve_done:
    rrmovq    %rax, %rbx                 # result to %rbx for halving p
    ret

# Subroutine fast_modulo(long dividend, long modulo)
# dividend in %rsi
# modulo in %rdi
# clobbers: %rax, %r8, %r9
#
# Complexity:
# This here is potentially a lot more expensive than halving and multiplying.
# Operations required depend on the difference between the dividend and the
# modulo. The worst case scenario is moduloing a large integer with 1.
# A single naive modulo with a large integer like 0xFFFF and 1 
# could single handedly take more than the optimal 250 000 operations.
# This is mitigated by doubling the modulo while iteratively decrementing
# the dividend. In the best case this could lead to O(log n) like 
# performance, but having to occasionally reset too large divisors 
# makes it slower. Here lies this subroutines potential for fine-tuning.
# Aggressively growing the divisor works on very large numbers as was
# the case in the earlier powmod assignment. Here just doubling it 
# performed better. This should manage an integer about 0xFFFF with modulo 1 in
# 16 iterations roughly meaning ~190 operations. The algorithm of course
# works very well with powers of two by avoiding resets.
fast_modulo:
    rrmovq    %rsi, %rax      # store the result in accumulator %rax
    rrmovq    %rsi, %r9       # Copy the dividend       
    subq      %rdi, %r9       # check for early return
    jl        modulo_done     # divisor larger than dividend -> do nothing
    rrmovq    %rdi, %r8       # %r8 = mutable divisor copy for doubling
    
modulo_loop:
    rrmovq    %rax, %r9       # Temp of result
    subq      %r8, %r9        # check if goes to zero or less
    cmovge    %r9, %rax       # update modulo if zero or above
    jle       modulo_done     # result was zero or below -> done

update_divisor:
    addq      %r8, %r8        # double the divisor (might need to quadruple this!)
    addq      %r8, %r8        # quadruple!
    rrmovq    %r8, %r9        # a temp for testing
    subq      %rax, %r9       # check if divisor is larger than current dividend
    jg        reset_divisor
    jmp       modulo_loop
    
reset_divisor:
    rrmovq    %rdi, %r8       # reset original divisor from %r9
    jmp       modulo_loop

modulo_done:
    ret

# Subroutine modpow(long base, long, exponent, long modulo)
# base in %rsi
# exponent in %rbx (immutable!)
# modulo in %rdi

# using:     %r14: result accumulator
#            %r13: bit mask
#            %r12: modulo
#            %r11: mutable base

# return value in %rax
# clobbers %rax, %r8-14
#
# Performance:
# This subroutine does multiple calls to other helper subroutines making it
# relatively expensive to run and more difficult to estimate performance-wise.
# Here the multiply and fast_modulo calls dominate. The fact that this 
# subroutine also iterates through bits helps with the estimations.
# Assuming a base of 0xFFFF and using the estimations of multiply and
# fast_modulo this could take ~700 operations per iteration meaning even
# ~11200 or more operations in a bad case.  
modpow:
    # Save copies of arguments to prevent clobbering by subroutines
    pushq     %rsi                  # save unmodified base on the stack
    rrmovq    %rsi, %r11            # base to %r11
    rrmovq    %rdi, %r12            # modulo to %r12
    
    # Calculate and assign base := base % modulo
    call      fast_modulo           # arguments already set fast_modulo(base, modulo)
    rrmovq    %rax, %r11            # init base in %r11
    
    # Start from result = 1
    irmovq    $1, %r14              # result accumulator = 1 in %r14
    
    # Initialize masks
    irmovq    $0x1, %r13            # init bit mask 0b1
    
modpow_loop:
    # Iterate for every relevant bit in the exponent
    rrmovq    %rbx, %rax            # tmp of exponent
    subq      %r13, %rax            # check for bits to process with mask
    jl        modpow_done           # no more bits to process
    rrmovq    %rbx, %rax            # tmp of exponent
    andq      %r13, %rax            # check if current bit is set
    je        modpow_update_params  # current bit not set, skip to iteration end
    
    # If bit is set: result := result * base % modulo
    rrmovq    %r14, %rsi            # 1. argument of multiply = result
    rrmovq    %r11, %rdi            # 2. argument of multiply = base
    call      multiply              # multiply(result, base)
    rrmovq    %rax, %rsi            # set result as 1. argument of fast_modulo
    rrmovq    %r12, %rdi            # 2. argument of fast_modulo = modulo
    call      fast_modulo           # fast_modulo(result, modulo)
    rrmovq    %rax, %r14            # update main result
 
modpow_update_params:
    # Shift iteration masks
    addq      %r13, %r13           # Left shift first bit mask
    
    # base := base * base % modulo
    rrmovq    %r11, %rsi           # 1. argument of multiply = base
    rrmovq    %r11, %rdi           # 1. argument of multiply = base
    call      multiply             # multiply(base, base)
    rrmovq    %rax, %rsi           # 1. argument of fast_modulo = base * base
    rrmovq    %r12, %rdi           # 2. argument of fast_modulo = modulo
    call      fast_modulo          # (base * base) % modulo
    rrmovq    %rax, %r11           # Update base
    jmp       modpow_loop
    
modpow_done:
    # restore modified argument values
    popq      %rsi                # restore base from stack
    rrmovq    %r12, %rdi          # restore modulo
    
    rrmovq    %r14, %rax          # return result in %rax
    ret

.pos 0x400
stack:

.pos 0x1000
witnesses:
# 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37
.align 8
.quad 2
.quad 3
.quad 5
.quad 7
.quad 11
.quad 13
.quad 17
.quad 19
.quad 23
.quad 29
.quad 31
.quad 37

#.pos 0x1800
#input_array:
#.align 8
##.quad 1 # not prime!
##.quad 2 # even
##.quad 9 # not prime
##.quad 1
#.quad 8335
#.quad 0
