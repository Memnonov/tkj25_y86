init:
    irmovq    stack, %rbp
    irmovq    stack, %rsp

# REMEMBER: %rax through %rdi equal DANGER ZONE! Save important stuff in nbr registers.
main:
    irmovq    $0xFFFFFFFFFFFFFFFF, %r11     # Constant: %r11 = Full mask
    irmovq    $0x1, %r12                    # Constant: %r12 = First bit mask
    
    irmovq    $666, %rsi                      # Set testing constants
    irmovq    $77, %rdi
    
    #call      multiply
    call      fast_modulo

done:
    halt

# Fast modulo: %rax = %rsi mod %rdi
fast_modulo:
    rrmovq    %rsi, %rax      # store the result in accumulator %rax
    rrmovq    %rsi, %rcx      # Copy the dividend       
    subq      %rdi, %rcx      # check for early return
    jl        modulo_done     # divisor larger than dividend -> do nothing
    rrmovq    %rdi, %rcx      # %rcx = mutable divisor copy for doubling
    
modulo_loop:
    rrmovq    %rax, %rdx      # Temp of result
    subq      %rcx, %rdx      # check if goes to zero or less
    cmovge    %rdx, %rax      # update modulo if zero or above
    jle       modulo_done     # result was zero or below

update_divisor:
    addq      %rcx, %rcx      # double the divisor
    rrmovq    %rcx, %rbx      # a temp for testing
    xorq      %r9, %rbx       # flips OF if the sign changed
    jl        reset_divisor
    rrmovq    %rax, %rbx      # a temp for testing
    subq      %rcx, %rbx      # check if divisor is larger than current dividend
    jl        reset_divisor
    jmp       modulo_loop
    
reset_divisor:
    rrmovq    %rdi, %rcx       # reset original divisor from %r9
    jmp       modulo_loop

modulo_done:
    ret



# Multiply the values in %rsi and %rdi: %rax = %rsi * %rsi
multiply:
    xorq      %rax, %rax                    # Initialize accumulator %rax = 0
    andq      %rsi, %rsi                    # Zero check operands for early return
    je        multiply_done
    andq      %rdi, %rdi                    # %rdi = the shifted operarand
    je        multiply_done
    rrmovq    %r11, %rdx                    # %rdx = full mask
    rrmovq    %r12, %rbx                    # %rbx = first_bit_mask

multiply_loop:
    rrmovq    %rsi, %rcx                     # temp of operand
    andq      %rdx, %rcx                     # Mask with full mask to see if any terms remain
    je        multiply_done                  # No more terms
    andq      %rbx, %rcx                     # Use small mask to check current term
    je        do_them_shifts                 # A term was 0
    addq      %rdi, %rax                     # result += current shift of the operand
    
do_them_shifts:
    addq      %rdx, %rdx                     # Left shift relevant registers      
    addq      %rbx, %rbx
    addq      %rdi, %rdi
    jmp       multiply_loop
    
multiply_done:
    ret                                      # Return result in %rax

.pos 0x400
stack:
