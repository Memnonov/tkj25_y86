init:
    irmovq    stack, %rbp
    irmovq    stack, %rsp

main:
    irmovq    $0xFFFFFFFFFFFFFFFF, %r11     # Constant: %r11 = Full mask
    irmovq    $0x1, %r12                    # Constant: %r12 = First bit mask
    
    irmovq    $112, %rsi                      # Set testing constants
    irmovq    $6969, %rdi
    
    call      multiply

done:
    halt

# Multiply the values in %rsi and %rdi: %rdi = %rsi * %rsi
multiply:
    xorq      %rax, %rax                    # Initialize accumulator as result = 0
    andq      %rsi, %rsi                    # Zero check operands for early return
    je        multiply_done
    andq      %rdi, %rdi                    # %rdi = the shifted operarand
    je        multiply_done
    rrmovq    %r11, %rdx                    # %rdx = full mask
    rrmovq    %r12, %rbx                    # %rbx = first_bit_mask

multiply_loop:
    rrmovq    %rsi, %rcx                     # temp of operand
    andq      %rdx, %rcx                     # Mask with full mask to see if any terms remain
    je        multiply_done                  # No more terms
    andq      %rbx, %rcx                     # Use small mask to check current term
    je        do_them_shifts                 # A term was 0
    addq      %rdi, %rax                     # result += current shift of the operand
    
do_them_shifts:
    addq      %rdx, %rdx                     # Left shift relevant registers      
    addq      %rbx, %rbx
    addq      %rdi, %rdi
    jmp       multiply_loop
    
multiply_done:
    rrmovq    %rax, %rdi                     # Return result in %rdi
    ret

.pos 0x400
stack:

.pos 0x408
full_mask:
    .quad 0xFFFFFFFFFFFFFFFF

.pos 0x410
first_bit_mask:
    .quad 1
